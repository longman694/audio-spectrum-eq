<!DOCTYPE html>
<html class="sl-theme-dark">
    <head>
        <title>Spectral Analysis + Phase Vectorscope</title>
        <style>
            body {
                color: #EEEEEE;
                background-color: #030303;
                font-family: sans-serif;
            }
            #control-container {
                width: 100%;
                display: flex;
                align-items: center;
                margin-top: 10px;
            }
            #audio-container {
                flex-grow: 1;
                margin-right: 0.2em;
            }
            #audio-container audio {
                width: 100%;
            }
            #container {
                background-color: #111111;
                margin-left: 255px;
                margin-right: 20px;
                height: 400px;
                position: relative;
                border-radius: 8px;
                overflow: hidden;
            }
            #vectorscope-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-top: 20px;
                margin-bottom: 20px;
            }
            canvas#vectorscope {
                background-color: #000;
                border: 1px solid #333;
                border-radius: 400px 400px 0 0; /* Semi-circle */
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
                /* Size */
                width: 800px; 
                height: 400px;
            }
            .center { text-align: center; }
            .phase-guide {
                position: absolute;
                top: 350px; 
                width: 800px;
                display: flex;
                justify-content: space-between;
                padding: 0 30px;
                font-size: 0.9em;
                color: #555;
                pointer-events: none;
            }
        </style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/themes/dark.css" />
        <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.0/cdn/shoelace-autoloader.js"></script>
    </head>
    <body>
        <div id="container">
            <div id="notice" style="padding: 20px;">
                <label for="btn_start">Select audio a file</label> <input id="btn_start" type="file" />
            </div>
        </div>
        <div id="control-container">
            <div id="audio-container"></div>
            <sl-button variant="default" size="large" style="display: none;" id="btn_destroy" circle>
                <sl-icon name="x-lg" label="Settings"></sl-icon>
            </sl-button>
        </div>
        <div id="message" class="box center"></div>

        <sl-tab-group>
            <sl-tab slot="nav" panel="eq">EQ</sl-tab>
            <sl-tab slot="nav" panel="analysis">Analysis</sl-tab>

            <sl-tab-panel name="eq">
                <div style="margin-top: 10px;">
                    <weq8-ui />
                </div>
            </sl-tab-panel>

            <sl-tab-panel name="analysis">
                <div id="vectorscope-container" style="position: relative; width: 800px; margin: 20px auto;">
                    <h3 style="margin: 0 0 10px 0; color: #888; text-align: center;">Polar Phase Scope</h3>
                    <canvas id="vectorscope" width="800" height="400"></canvas>
                    <div class="phase-guide">
                        <span>-1 (Invert)</span>
                        <span>L</span>
                        <span>+1 (Mono)</span>
                        <span>R</span>
                        <span>-1 (Invert)</span>
                    </div>
                </div>
            </sl-tab-panel>
        </sl-tab-group>

        <div class="center">more <a href="https://audiomotion.dev/#/" target="_blank">settings</a></div>

        <script type="module">
            import AudioMotionAnalyzer from 'https://cdn.skypack.dev/audiomotion-analyzer?min';
            import { WEQ8Runtime } from "https://cdn.skypack.dev/weq8";
            import "https://cdn.skypack.dev/weq8/ui";
    
            const container       = document.getElementById('container'),
                  audioContainer = document.getElementById('audio-container'),
                  destroyButton  = document.getElementById('btn_destroy'),
                  startButton    = document.getElementById('btn_start'),
                  messageDiv      = document.getElementById('message'),
                  noticeDiv       = document.getElementById('notice'),
                  canvasVS        = document.getElementById('vectorscope');
    
            destroyButton.addEventListener( 'click', destroy );
            startButton.addEventListener( 'change', initialize );
    
            let audioEl, audioMotion, source, weq8;
            let audioContext;
            
            // --- VECTORSCOPE VARIABLES ---
            let vsCtx, vsAnimationId;
            let tapSource = null;
            let splitter, analyserL, analyserR;

            // Expanded bins to cover full 180 degrees nicely
            const numAngleBins = 180; 
            
            // Layer 1: The Decay Envelope (Cyan)
            let decayBins = new Float32Array(numAngleBins).fill(0);
            const envelopeDecay = 0.92; 
            
            // Layer 2: The History Peak (White)
            const historyLimit = 120; // 2 seconds
            let historyBins = []; 

            function initialize() {
                vsCtx = canvasVS.getContext('2d');

                var file = this.files[0]
                var blob = window.URL || window.webkitURL;
                if (!blob) { console.log('No Blob URL support'); return; }
                var fileURL = blob.createObjectURL(file);

                audioEl = new Audio(fileURL);
                audioEl.controls = true;
                audioEl.crossOrigin = 'anonymous';
                audioEl.onloadstart  = () => messageDiv.innerText = 'Buffering...';
                audioEl.onloadeddata = () => {
                    messageDiv.innerText = '';
                    audioEl.play();
                    drawVectorscope(); 
                }
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                source = audioContext.createMediaElementSource(audioEl);
                weq8 = new WEQ8Runtime(audioContext);
                
                audioMotion = new AudioMotionAnalyzer( container, {
                    audioCtx: audioContext, connectSpeakers: false, frequencyScale: 'log',
                    minFreq: 10, maxFreq: 24000, gradient: 'prism', mode: 0,
                    ansiBands: true, smoothing: 0.4, channelLayout: 'dual-vertical',
                });

                // --- ROUTING ---
                source.connect(weq8.input);
                audioMotion.connectInput(weq8);
                audioMotion.connectOutput(audioContext.destination);

                // Tap signal for Vectorscope
                if (audioMotion.analyzer) {
                     tapSource = audioMotion.analyzer;
                } else {
                     tapSource = weq8;
                }
                
                // --- PHASE ANALYSIS SETUP ---
                // We use TimeDomain data now because FFT Magnitude loses phase info.
                // TimeDomain allows us to see Inverted/Anti-phase signals.
                splitter = audioContext.createChannelSplitter(2);
                analyserL = audioContext.createAnalyser();
                analyserR = audioContext.createAnalyser();
                
                // 4096 gives us good resolution for the Lissajous calculation
                analyserL.fftSize = 4096; 
                analyserR.fftSize = 4096;

                tapSource.connect(splitter);
                splitter.connect(analyserL, 0);
                splitter.connect(analyserR, 1);

                document.querySelector("weq8-ui").runtime = weq8;
                audioContainer.append( audioEl );
                noticeDiv.style.display = 'none';
                destroyButton.style.display = 'block';
            }


            // --- DRAWING LOGIC ---
            function drawVectorscope() {
                if(!analyserL || !analyserR || !vsCtx) return;

                const width = canvasVS.width;
                const height = canvasVS.height;
                const bufferLength = analyserL.frequencyBinCount;
                
                const dataL = new Uint8Array(bufferLength);
                const dataR = new Uint8Array(bufferLength);
                
                // Get WAVEFORM data (Time Domain)
                // Values are 0-255. 128 is Zero/Silence.
                analyserL.getByteTimeDomainData(dataL);
                analyserR.getByteTimeDomainData(dataR);

                let compositeFrameBins = new Float32Array(numAngleBins).fill(0);

                // Analyze waveform
                for (let i = 0; i < bufferLength; i+=4) { // Step 4 for perf
                    // Normalize to -1.0 to 1.0
                    const L = (dataL[i] / 128.0) - 1.0;
                    const R = (dataR[i] / 128.0) - 1.0;
                    
                    // Lissajous / Mid-Side Conversion
                    // X = Side (R - L to match standard orientation)
                    // Y = Mid  (L + R)
                    let x = (R - L);
                    let y = (L + R);

                    // Magnitude (Radius)
                    // We multiply by 0.707 to keep scale roughly 0..1
                    const currentMag = Math.sqrt(x*x + y*y) * 0.707; 

                    if (currentMag < 0.01) continue;

                    // Angle Calculation (Phase)
                    // We want to map half-circle upper hemisphere.
                    // If y < 0 (lower hemisphere), we flip vector because audio polarity 
                    // is symmetric for this visualization (-L/-R is same energy as L/R).
                    if (y < 0) {
                        x = -x;
                        y = -y;
                    }

                    // atan2(y, x) gives angle. 
                    // 0 = Right, PI = Left, PI/2 = Up (Mono).
                    const angle = Math.atan2(y, x); 

                    // Map Angle (0 to PI) to Bin Index
                    // angle is in radians 0..3.14159
                    let binIndex = Math.floor((angle / Math.PI) * (numAngleBins - 1));
                    
                    // Reverse index so Left is Left on screen?
                    // atan2: 0 is Right. PI is Left.
                    // So Left(PI) -> Index High. Right(0) -> Index Low.
                    // If we want array[0] to be Left (visual 180 deg):
                    binIndex = (numAngleBins - 1) - binIndex;
                    
                    binIndex = Math.max(0, Math.min(numAngleBins-1, binIndex));

                    // Store Peak
                    if (currentMag > compositeFrameBins[binIndex]) {
                         compositeFrameBins[binIndex] = currentMag;
                    }
                }

                // Update Decay
                for (let i = 0; i < numAngleBins; i++) {
                    decayBins[i] *= envelopeDecay; 
                    if (compositeFrameBins[i] > decayBins[i]) {
                        decayBins[i] = compositeFrameBins[i]; 
                    }
                }

                // Update History
                historyBins.push(compositeFrameBins); 
                if (historyBins.length > historyLimit) {
                    historyBins.shift(); 
                }
                
                let maxWindowBins = new Float32Array(numAngleBins).fill(0);
                for (let h = 0; h < historyBins.length; h++) {
                    const frame = historyBins[h];
                    for (let b = 0; b < numAngleBins; b++) {
                        if (frame[b] > maxWindowBins[b]) {
                            maxWindowBins[b] = frame[b];
                        }
                    }
                }

                // Draw
                vsCtx.clearRect(0,0, width, height);
                vsCtx.fillStyle = '#050505';
                vsCtx.fillRect(0,0,width,height);

                drawGuideLines(width, height);

                function drawOutline(bins, color, widthVal, fillStyle) {
                    const centerX = width / 2;
                    const bottomY = height - 5; 
                    const maxRadius = Math.min(width / 2, height) * 0.95;

                    vsCtx.beginPath();
                    
                    // We draw from Right (0 deg) to Left (180 deg)
                    // Bins[0] corresponds to Left (PI) based on our reverse mapping above?
                    // Let's check:
                    // binIndex = (numAngleBins - 1) - (angle/PI * max)
                    // Angle PI (Left) -> binIndex = 0.
                    // Angle 0 (Right) -> binIndex = max.
                    
                    // So we iterate i from 0 to max.
                    // i=0 is Left (PI). i=max is Right (0).
                    
                    // Start from Left side (PI)
                    // angleRad = PI - (percent * PI)
                    
                    for (let i = 0; i < numAngleBins; i++) {
                        let magnitude = Math.pow(bins[i], 0.8);
                        const baseRadius = 5; 
                        const finalRadius = baseRadius + (magnitude * (maxRadius - baseRadius));
                        
                        const percent = i / (numAngleBins - 1);
                        const angleRad = Math.PI - (percent * Math.PI); // PI to 0

                        const drawX = centerX + (Math.cos(angleRad) * finalRadius);
                        const drawY = bottomY - (Math.sin(angleRad) * finalRadius);
                        
                        if (i===0) vsCtx.moveTo(drawX, drawY);
                        else vsCtx.lineTo(drawX, drawY);
                    }
                    
                    // Close shape to center for fill
                    vsCtx.lineTo(centerX, bottomY); 
                    vsCtx.closePath();

                    if(fillStyle) {
                        vsCtx.fillStyle = fillStyle;
                        vsCtx.fill();
                    }
                    vsCtx.lineWidth = widthVal;
                    vsCtx.strokeStyle = color;
                    vsCtx.stroke();
                }

                // Max Window (Ghost)
                drawOutline(maxWindowBins, 'rgba(255, 255, 255, 0.4)', 1, null);

                // Decay (Active)
                drawOutline(decayBins, '#00ccff', 2, 'rgba(0, 204, 255, 0.15)');

                vsAnimationId = requestAnimationFrame(drawVectorscope);
            }

            function drawGuideLines(w, h) {
                vsCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                vsCtx.lineWidth = 1;
                const cx = w/2;
                const by = h-5;
                const r = Math.min(w/2, h) * 0.95;
                vsCtx.beginPath();
                
                // 135 deg (Left)
                vsCtx.moveTo(cx, by); vsCtx.lineTo(cx + Math.cos(2.356)*r, by - Math.sin(2.356)*r);
                // 45 deg (Right)
                vsCtx.moveTo(cx, by); vsCtx.lineTo(cx + Math.cos(0.785)*r, by - Math.sin(0.785)*r);
                // Center (Mono)
                vsCtx.moveTo(cx, by); vsCtx.lineTo(cx, by - r);
                
                // Flat Lines (Anti-phase)
                vsCtx.moveTo(cx, by); vsCtx.lineTo(cx - r, by); // Left flat
                vsCtx.moveTo(cx, by); vsCtx.lineTo(cx + r, by); // Right flat
                
                vsCtx.stroke();
            }
    
            function destroy() {
                if(vsAnimationId) cancelAnimationFrame(vsAnimationId);
                audioEl.pause(); 
                audioEl.remove(); 
                audioMotion.destroy();
                historyBins = [];
                audioMotion = null; 
                audioEl = null;
                noticeDiv.style.display = ''; 
                destroyButton.style.display = 'none';
            }
        </script>
    </body>
</html>